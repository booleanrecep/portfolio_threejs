<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <meta property="og:title" content="R3C3P" />
    <meta property="op:type" content="website"/>
    <meta property="og:description" content="R3C3P Website with 3D Model"/>
    <meta property="og:url" content="r3c3p.netlify.app"/>
    <meta property="og:image" content="ss.PNG"/>
    <style>
      body {
        margin: 0;
      }
      #cnv {
        width: 100vw;
        height: 100vh;
        display: block;
        background: url("vp.jpg") no-repeat center center;
        background-size: cover;
      }
    </style>
  </head>
  <body>
    <canvas id="cnv"></canvas>
    <div id="root"></div>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.117.1/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.117.1/examples/jsm/controls/OrbitControls.js";
      import { PLYLoader } from "https://unpkg.com/three@0.117.1/examples/jsm/loaders/PLYLoader.js";

      let meshDolphins,meshStatue, canvas, camera, cameraTarget, scene, renderer, controls;

      init();
      animate();

      function init() {
        canvas = document.getElementById("cnv");
        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          15
        );
        camera.position.set(3, 0.15, 3);

        cameraTarget = new THREE.Vector3(0, -0.1, 0);

        scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x72645b);
        // scene.fog = new THREE.Fog(0x72645b, 2, 15);

        // Ground
        controls = new OrbitControls(camera, canvas);
        controls.update();
        // const plane = new THREE.Mesh(
        //   new THREE.PlaneBufferGeometry(40, 40),
        //   new THREE.MeshPhongMaterial({ color: 0x999999, specular: 0x101010 })
        // );
        // plane.rotation.x = -Math.PI / 2;
        // plane.position.y = -0.5;
        // scene.add(plane);

        // plane.receiveShadow = true;

        // PLY file

        const loader = new PLYLoader();
        loader.load("./models/dolphins_colored.ply", function(geometry) {
          geometry.computeVertexNormals();

          const material = new THREE.MeshStandardMaterial({
            color: 0x0055ff,
            flatShading: true
          });
          meshDolphins = new THREE.Mesh(geometry, material);

          meshDolphins.position.y = -0.2;
          meshDolphins.position.z = 0.3;
          meshDolphins.rotation.x = -Math.PI / 2;
          meshDolphins.scale.multiplyScalar(0.001);

          meshDolphins.castShadow = true;
          meshDolphins.receiveShadow = true;

          // scene.add(meshDolphins);
        });

        loader.load("./models/Lucy100k.ply", function(geometry) {
          geometry.computeVertexNormals();

          const material = new THREE.MeshStandardMaterial({
            color: 0x0055ff,
            flatShading: true
          });
          meshStatue = new THREE.Mesh(geometry, material);

          meshStatue.position.x = 0.5;
          meshStatue.position.y = -0.02;
          meshStatue.position.z = -0.2;
          meshStatue.scale.multiplyScalar(0.0006);

          meshStatue.castShadow = true;
          meshStatue.receiveShadow = true;

          scene.add(meshStatue);
        });

        // Lights

        scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

        addShadowedLight(1, 1, 1, 0xffffff, 1.35);
        addShadowedLight(0.5, 1, -1, 0xffaa00, 1);

        // renderer

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true,alpha:true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;

        renderer.shadowMap.enabled = true;

        // stats

        // resize

        window.addEventListener("resize", onWindowResize, false);
      }

      function addShadowedLight(x, y, z, color, intensity) {
        const directionalLight = new THREE.DirectionalLight(color, intensity);
        directionalLight.position.set(x, y, z);
        scene.add(directionalLight);

        directionalLight.castShadow = true;

        const d = 1;
        directionalLight.shadow.camera.left = -d;
        directionalLight.shadow.camera.right = d;
        directionalLight.shadow.camera.top = d;
        directionalLight.shadow.camera.bottom = -d;

        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 4;

        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;

        directionalLight.shadow.bias = -0.001;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        if( window.innerWidth <= 600) {
          controls.addEventListener("change", render);
          requestAnimationFrame(null);

          
        } 
        requestAnimationFrame(animate);
       
        render();
        controls.update();
      }
      controls.addEventListener("change", render);
      window.addEventListener("resize", render);
      function render() {
        const timer = Date.now() * 0.0005;

        // camera.position.x = Math.sin(timer) * 2.5;
        // camera.position.z = Math.cos(timer) * 2.5;
        meshStatue.rotation.y += Math.sin(timer*0.5) * 0.04;
        camera.lookAt(cameraTarget);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
